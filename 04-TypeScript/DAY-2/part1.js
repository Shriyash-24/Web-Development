"use strict";
let num = 10;
num = "Rohit"; // Error.
let x = 10;
x = "Rohit"; // Error. But I didn't even define its type then why still error? 
// Jis value ke sath initialize karoge vahi uska type ban jayega. This is known as Type Inference.
/*
Type Inference in TypeScript refers to the ability of the TypeScript compiler to automatically determine the type of a variable based on the value assigned to it. This means that even if you don't explicitly specify a type, TypeScript can infer the most appropriate type and apply it.
*/
let val = "Rohit";
val = 20; // Error because val's type is string.
let money; // Any type.
money = 20; // No error.
money = "Shriyash"; // No error
// money ke andar kuch bhi aa sakta hai. Kyuki meine usme initialize bhi nahi kara and type bhi define nahi kara.
/*
Represents any type of value. When a variable has the any type, it can be assigned any value, and no type checking is done.
*/
let val2;
val2 = 20;
val2 = "Rohit";
/*
The any and unknown types in TypeScript are both used to represent values of any type.

The unknown type is safer than any because you cannot perform operations on an unknown value without first narrowing its type through type checks.
*/
// Matlab tu any type wale pe kuch bhi operation kar sakta hai. Unknown any type mei value ko consume karke, type checking hone ke baad hii operation honge.
if (typeof val2 === 'string')
    console.log(val2.toUpperCase());
if (typeof val2 === 'number')
    console.log(val2.toFixed(2));
// Non Primitive Types.
let arr = [2, 4, 5, 7, 11];
let arr2 = [2, 3, 6, 4, 3]; // compiler figures out the array's type.
let arr3 = ["Rohit", 20, 22, "Lol"];
arr3.push(true); // Error because only string and numbers I can take.
let arr4 = ["Rohit", true];
// Tuples
let t1 = ["Rohit", 10];
// Size is fixed here and here 1st index would be index and 2nd index is number. Define for each element's index.
// C++ Code.
// Compile Time
// Entire code file is converted into M/C code file. 
// Run Time
// Now this Machine Code is sent to CPU to run this file.
// Java Code
// Compile Time
// Entire code file is converted into ByteCode.
// Run Time
// Now this Byte Code is executed.
/*
COMPILE TIME --> Compile-time refers to the phase when the source code is translated into machine code or an intermediate format (e.g., bytecode). This is done by a compiler.

Errors detected at this phase are called compile-time errors.
Examples of compile-time errors include:
Syntax errors (e.g., missing semicolons).
Type mismatches (e.g., assigning a string to a variable declared as a number in TypeScript).
Variable declarations without initialization (if required by the language).
*/
/*
Runtime refers to the phase when the program is executed after it has been compiled (or interpreted).
Errors detected during this phase are called runtime errors.
Examples of runtime errors include:
Dividing by zero.
Accessing undefined variables or null references.
Running out of memory.
Examples of Runtime Activities:
1) Executing code instructions.
2) Handling user inputs.
3) Interacting with APIs or databases
*/
// JavaScript Code
// Interpreted Language --> Line by Line execution starts. I have to convert line by line into binary, baar baar convert karke execution hoga jis se context switching increase hogi. 
// That's why JavaScript is slow.
// But then optimization came known as JIT Compiler.
// JIT --> Just In Time Language.
// Combination of compile time and interpreted. 
// As default it works as Interpreted Language, but when function or loop came which will run many times, then that function will be converted to machine code in first time and that function is directly sent to CPU without converting it at the second time. For 1st time, I will treat it like interpreted language, but then compile time language.
// Platform Independent V/S Platform Dependent
// C,C++ --> Platform Dependent --> It means machine code is generated by taking the machine OS into account.
// Java,JS --> Platform Independent --> Java generates ByteCode, it will execute on any machine. For JS, we have to give code only.
// TypeScript is Transpiled Language. Converting from one language into another.
// OBJECTS
let obj1 = {
    name: "Rohit",
    age: 20,
    gender: "female"
};
// Compiler understands it like this --> 
/*
{
    name: string;
    age: number;
    gender: string;
}
*/
let obj2 = {
    name: "Shriyash",
    age: 20,
    gender: "Male"
};
// Inline
let person;
person = {
    name: "Shriyash",
    age: 20,
    balance: 0
};
let cu1 = {
    name: "Shriyash",
    age: 20,
    id: "f1"
};
